<!DOCTYPE html>
<html>
<head>
  <title>cool computer cube computations (CCCC)</title>
</head>
<body>
  <div class="container">
    <h1>This is a cube solver</h1>
    <div class="card">
      <p>Here is some information</p>
    </div>
  </div>
	<script src="{{ url_for('static', filename='libs/three.min.js') }}"></script>
  <script>
let camera, scene, renderer;
let matrices = {};  // external rotation matricies
let maxCt = 15;
let dth = Math.PI/(2*(maxCt+1));
let rotateIdxs;
let geometries = [];
let materials = [];
let meshes = [];
let dims = [2, 4];
let w = 0.3;
let translates = [[-w/2, -w/2, +w/2], [-w/2, w/2, +w/2], [w/2, w/2, +w/2], [w/2, -w/2, +w/2],
                  [-w/2, -w/2, -w/2], [-w/2, w/2, -w/2], [w/2, w/2, -w/2], [w/2, -w/2, -w/2]];
const COLORS = [0x4286f4, 0xdb2f04, 0x04db2f, 0xeff707, 0xf78307, 0xffffff];
const ORIGIN = new THREE.Vector3(0,0,0);
let rotationGoing = false;
/*


    |
    |
---------x
    |
    |
    y

  z is straight out of the screen
*/

init();
animate();

function init() {
  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
  camera.position.z = 1;

  scene = new THREE.Scene();

  for (let i = 0; i < dims[0]; i++)
  {
    geometries.push([]);
    materials.push([]);
    meshes.push([]);
    for (let k = 0; k < dims[1]; k++)
    {
      geometries[i].push(new THREE.BoxGeometry(0.95*w, 0.95*w, 0.95*w));
      for (let j = 0; j < geometries[i][k].faces.length/2; j++) {
        geometries[i][k].faces[2*j].color.setHex(COLORS[j]);
        geometries[i][k].faces[2*j+1].color.setHex(COLORS[j]);
      }
      materials[i].push(new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } ));

      meshes[i].push(new THREE.Mesh(geometries[i][k], materials[i][k]));
      meshes[i][k].translateX(translates[dims[1]*i+k][0]);
      meshes[i][k].translateY(translates[dims[1]*i+k][1]);
      meshes[i][k].translateZ(translates[dims[1]*i+k][2]);

      scene.add(meshes[i][k]);
    }
  }

  matrices['F'] = new THREE.Matrix4();
  matrices['F'].set(
    Math.cos(dth), -Math.sin(dth), 0, 0,
    Math.sin(dth), Math.cos(dth), 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  );
  matrices['B'] = matrices['F'];

  matrices['Fi'] = new THREE.Matrix4();
  matrices['Fi'].set(
    Math.cos(-dth), -Math.sin(-dth), 0, 0,
    Math.sin(-dth), Math.cos(-dth), 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  );
  matrices['Bi'] = matrices['Fi'];

  // this one is wrong
  matrices['U'] = new THREE.Matrix4();
  matrices['U'].set(
    Math.cos(dth), 0, -Math.sin(dth), 0,
    0, 1, 0, 0,
    Math.sin(dth), 0, Math.cos(dth), 0,
    0, 0, 0, 1
  );
  matrices['D'] = matrices['U'];

  matrices['Ui'] = new THREE.Matrix4();
  matrices['Ui'].set(
    Math.cos(-dth), 0, -Math.sin(-dth), 0,
    0, 1, 0, 0,
    Math.sin(-dth), 0, Math.cos(-dth), 0,
    0, 0, 0, 1
  );
  matrices['Di'] = matrices['Ui'];

  matrices['R'] = new THREE.Matrix4();
  matrices['R'].set(
    1, 0, 0, 0,
    0, Math.cos(-dth), -Math.sin(-dth), 0,
    0, Math.sin(-dth), Math.cos(-dth), 0,
    0, 0, 0, 1
  );
  matrices['L'] = matrices['R'];

  matrices['Ri'] = new THREE.Matrix4();
  matrices['Ri'].set(
    1, 0, 0, 0,
    0, Math.cos(dth), -Math.sin(dth), 0,
    0, Math.sin(dth), Math.cos(dth), 0,
    0, 0, 0, 1
  );
  matrices['Li'] = matrices['Ri'];


  rotateIdxs = {
    "R":  [[0,2],[0,3],[1,2],[1,3]],
    "Ri": [[0,2],[0,3],[1,2],[1,3]],

    "L":  [[0,0],[0,1],[1,0],[1,1]],
    "Li": [[0,0],[0,1],[1,0],[1,1]],

    "U":  [[0,1],[0,2],[1,1],[1,2]],
    "Ui": [[0,1],[0,2],[1,1],[1,2]],

    "D":  [[0,0],[0,3],[1,0],[1,3]],
    "Di": [[0,0],[0,3],[1,0],[1,3]],

    "F":  [[0,0],[0,1],[0,2],[0,3]],
    "Fi": [[0,0],[0,1],[0,2],[0,3]],

    "B":  [[1,1],[1,2],[1,2],[1,3]],
    "Bi": [[1,1],[1,2],[1,2],[1,3]],
  }


  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild( renderer.domElement );
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

function maybeRotate(type, ct) {
  if (!rotationGoing) {
    rotation(type, ct);
  }
}

function rotation(type, ct) {
  rotationGoing = true;
  if (ct > maxCt) {
    rotationGoing = false;
    return true;
  }
  let idxs = rotateIdxs[type];
  for (let i in idxs) {
    meshes[idxs[i][0]][idxs[i][1]].applyMatrix(matrices[type]);
  }
  setTimeout(rotation, 200, type, ct+1);
}

  </script>

  <div id="buttons"></div>

  <script>
    let tmp = "";
    for (let key in rotateIdxs) {
      tmp += "<button onclick='maybeRotate(\""+key+"\",0);'>"+ key+"</button>"
    }
    document.getElementById('buttons').innerHTML= tmp;
  </script>

</body>
</html>

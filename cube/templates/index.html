<!DOCTYPE html>
<html>
<head>
  <!-- some libs -->
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  <title>cool computer cube computations (CCCC)</title>
</head>
<body>
  <div class="container">
    <h1>This is a cube solver</h1>
    <div class="card">
      <p>Here is some information</p>
      <p>This is a very compelling reason to like our project</p>
    </div>
    <div>
      <button onclick='scene.rotateX(+0.2)' class="btn btn-lg">+X</button>
      <button onclick='scene.rotateX(-0.2)' class="btn btn-lg">-X</button>
      <button onclick='scene.rotateY(+0.2)' class="btn btn-lg">+Y</button>
      <button onclick='scene.rotateY(-0.2)' class="btn btn-lg">-Y</button>
      <button onclick='scene.rotateZ(+0.2)' class="btn btn-lg">+Z</button>
      <button onclick='scene.rotateZ(-0.2)' class="btn btn-lg">-Z</button>
    </div>
  </div>
  <script src='../static/libs/three.min.js'></script>
  <!-- If you ever legit use the flask backend PLEASE SWITCH TO THIS -->
	<!-- <script src="{{ url_for('static', filename='libs/three.min.js') }}"></script> -->
  <script>
let camera, scene, renderer;
let matrices = {};  // external rotation matricies
let maxCt = 5;
let dth = Math.PI/(2*(maxCt+1));
let rotateIdxs, reindexIdxs;
let geometries = [];
let materials = [];
let meshes = [];
let dims = [2, 4];
let w = 0.3;
let meshInds = [
  [[0,0],[0,1],[0,2],[0,3]],
  [[1,0],[1,1],[1,2],[1,3]]
];
let translates = [[-w/2, -w/2, +w/2], [-w/2, w/2, +w/2], [w/2, w/2, +w/2], [w/2, -w/2, +w/2],
                  [-w/2, -w/2, -w/2], [-w/2, w/2, -w/2], [w/2, w/2, -w/2], [w/2, -w/2, -w/2]];
const COLORS = [0x4286f4, 0xdb2f04, 0x04db2f, 0xeff707, 0xf78307, 0xffffff];
const ORIGIN = new THREE.Vector3(0,0,0);
let rotationGoing = false;
/*


    |
    |
---------x
    |
    |
    y

  z is straight out of the screen
*/

init();
animate();

function init() {
  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10);
  camera.position.z = 1;

  scene = new THREE.Scene();

  for (let i = 0; i < dims[0]; i++)
  {
    geometries.push([]);
    materials.push([]);
    meshes.push([]);
    for (let k = 0; k < dims[1]; k++)
    {
      geometries[i].push(new THREE.BoxGeometry(0.95*w, 0.95*w, 0.95*w));
      for (let j = 0; j < geometries[i][k].faces.length/2; j++) {
        geometries[i][k].faces[2*j].color.setHex(COLORS[j]);
        geometries[i][k].faces[2*j+1].color.setHex(COLORS[j]);
      }
      materials[i].push(new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } ));

      meshes[i].push(new THREE.Mesh(geometries[i][k], materials[i][k]));
      meshes[i][k].translateX(translates[dims[1]*i+k][0]);
      meshes[i][k].translateY(translates[dims[1]*i+k][1]);
      meshes[i][k].translateZ(translates[dims[1]*i+k][2]);

      scene.add(meshes[i][k]);
    }
  }

  matrices['F'] = new THREE.Matrix4();
  matrices['F'].set(
    Math.cos(dth), -Math.sin(dth), 0, 0,
    Math.sin(dth), Math.cos(dth), 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  );
  matrices['B'] = matrices['F'];

  matrices['Fi'] = new THREE.Matrix4();
  matrices['Fi'].set(
    Math.cos(-dth), -Math.sin(-dth), 0, 0,
    Math.sin(-dth), Math.cos(-dth), 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  );
  matrices['Bi'] = matrices['Fi'];

  matrices['U'] = new THREE.Matrix4();
  matrices['U'].set(
    Math.cos(dth), 0, -Math.sin(dth), 0,
    0, 1, 0, 0,
    Math.sin(dth), 0, Math.cos(dth), 0,
    0, 0, 0, 1
  );
  matrices['D'] = matrices['U'];

  matrices['Ui'] = new THREE.Matrix4();
  matrices['Ui'].set(
    Math.cos(-dth), 0, -Math.sin(-dth), 0,
    0, 1, 0, 0,
    Math.sin(-dth), 0, Math.cos(-dth), 0,
    0, 0, 0, 1
  );
  matrices['Di'] = matrices['Ui'];

  matrices['R'] = new THREE.Matrix4();
  matrices['R'].set(
    1, 0, 0, 0,
    0, Math.cos(-dth), -Math.sin(-dth), 0,
    0, Math.sin(-dth), Math.cos(-dth), 0,
    0, 0, 0, 1
  );
  matrices['L'] = matrices['R'];

  matrices['Ri'] = new THREE.Matrix4();
  matrices['Ri'].set(
    1, 0, 0, 0,
    0, Math.cos(dth), -Math.sin(dth), 0,
    0, Math.sin(dth), Math.cos(dth), 0,
    0, 0, 0, 1
  );
  matrices['Li'] = matrices['Ri'];


  rotateIdxs = {
    "R":  [[0,3],[0,2],[1,2],[1,3]],
    "Ri": [[0,3],[0,2],[1,2],[1,3]],

    "L":  [[0,0],[0,1],[1,1],[1,0]],
    "Li": [[0,0],[0,1],[1,1],[1,0]],

    "U":  [[0,1],[1,1],[1,2],[0,2]],
    "Ui": [[0,1],[1,1],[1,2],[0,2]],

    "D":  [[0,0],[1,0],[1,3],[0,3]],
    "Di": [[0,0],[1,0],[1,3],[0,3]],

    "F":  [[0,0],[0,1],[0,2],[0,3]],
    "Fi": [[0,0],[0,1],[0,2],[0,3]],

    "B":  [[1,0],[1,1],[1,2],[1,3]],
    "Bi": [[1,0],[1,1],[1,2],[1,3]]
  }

  for (let key in rotateIdxs) {
    if (key.indexOf('i')!=-1)
    {
      rotateIdxs[key] = rotateIdxs[key].reverse();
    }
  }

  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild( renderer.domElement );
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

function maybeRotate(type, ct) {
  if (!rotationGoing) {
    rotation(type, ct);
  }
}

function getMeshIdxs(coordIdxs) {
  let meshIdxs = [];
  for (let i in coordIdxs) {
    meshIdxs.push(meshInds[coordIdxs[i][0]][coordIdxs[i][1]]);
  }
  return meshIdxs;
}

function rotation(type, ct) {
  rotationGoing = true;
  if (ct > maxCt) {
    rotationGoing = false;
    let idxs = rotateIdxs[type];
    let midxs = getMeshIdxs(idxs);
    let tmpIdxs = [];
    let n = idxs.length;
    for (let i = 0; i < n; i++)
    {
      tmpIdxs.push(midxs[i].slice());
    }
    for (let i = 0; i < n; i++)
    {
      meshInds[idxs[(i+1)%n][0]][idxs[(i+1)%n][1]] = tmpIdxs[i];
    }

    return true;
  }
  let midxs = getMeshIdxs(rotateIdxs[type]);
  for (let i in midxs) {
    meshes[midxs[i][0]][midxs[i][1]].applyMatrix(matrices[type]);
  }
  setTimeout(rotation, 200, type, ct+1);
}

  </script>

  <div id="buttons"></div>

  <script>
    let tmp = "";
    for (let key in rotateIdxs) {
      tmp += "<button class='btn btn-lg' onclick='maybeRotate(\""+key+"\",0);'>"+ key+"</button>"
    }
    document.getElementById('buttons').innerHTML= tmp;
  </script>

</body>
</html>
